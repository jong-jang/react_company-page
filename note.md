# 리액트 정리 노트

## RealDOM - 실제돔

- HTML태그를 이용해서 구조를 만들면 브라우저가 이를 해석해서 실제 DOM형태로 객체를 만들고 화면에 렌더링하는 방식

<hr>

## VirtualDOM - 가상돔

- 실제 브라우저에 리얼돔으로 변환되기전 메모리상에서 DOM구조를 스크립트로 가상으로 만들어서 기존의 DOM구조와 차이점을 분석
- 기존DOM에서 변경되는 부분을 메모리상에서 빠르게 수정해서 리얼돔으로 출력하는 형태 JSX
- 리액트 자체적으로 가상돔을 편하게 생성해주는 문법체계 (자바스크립트로 일일이 노드를 생성해서 돔을 제작하던 방식을 마치 HTML입력하는 것처럼 편하게 변경한 표현방식)

<hr>

## 컴포넌트 함수

- JSX를 반환해서 가상돔을 생성해주는 함수
- 함수명을 대문자로 시작
- export형식으로 내보내야지 다른 파일에서 import해올수 있음
- 화살표함수 형태로도 제작 가능
- 하나의 컴포넌트 함수는 단일 JSX요소만 리턴 가능
- 복수개의 요소를 리턴하고 싶을때에는 wrapping태그로 감싸줌
- 중첩되는 wrapping요소가 불필요시에는 fragment로 감싸줌 <></>
- 화살표함수로 컴포넌트 제작시 중괄호 return문은 생략 가능

<hr>

## e.target vs e.currentTarget

- e.currentTarget : 이벤트구문상에서 이벤트가 연결되어 있는 선택자를 지칭
- e.target : 화면상에서 실제 이벤트가 발생한 대상을 지칭

<hr>

## 불변성 (immutability)

- 불변성 (immutability) : 원형을 훼손시키지 않으면서 원본을 유지한채로 복사본을 변경후 비교하는 형태
- 리액트에서는 원본대비 변경된 부분을 비교해서 화면을 렌더링하기 때문에 불변성 유지가 필수
- 리액트에서는 원본데이터와 변경될 데이터가 모두 있어야함
- 참조형 자료를 변경할때에는 무조건 deep copy처리
- 특정요소를 반복 돌릴때에는 무조건 map함수 활용(원배열을 복사하면서 반복처리)
- JSX 안쪽에서는 map함수 외에는 반복처리 불가
- JSX에서 동적으로 반복생성되는 요소는 무조건 고유의 key값을 부여 (리액트로 하여금 반복도를 개별적으로 인지시키기 위함)

<hr>

## 리액트에서의 데이터 전달 방식 (단뱡향 데이터 바인딩 채택)

- 부모에서 자식으로 데이터 전달 가능
- 부모에서 자식으로 데이터를 전달하기 위해서는 props라는 파라미터 활용

<hr>

## State

- 컴포넌트 함수 안쪽에서 변수에 특정 정보값을 담아놓으면 해당 함수가 호출될 때마다 다시 변수에 담긴 값이 초기화 됨
- 컴포넌트함수 안쪽에서 특정 정보값을 이벤트에 의해서 바꾸면 컴포넌트함수는 다음번 호출때 변경점이 반영이 됨
- State: 컴포넌트 내부에서 특정 정보값을 담아두는 그릇 - 해당 값이 바뀌게 되면 컴포넌트 함수자체를 재호출 (재랜더링) 바뀐 값으로 새로운 화면을 갱신
- [state가 담김 그릇, 해당 State값을 변경해주는 전용함수] = useState(초기값)
- uss 입력후 3번째 탭 선택하면 자동완성 가능
- 컴포넌트에서 State값을 변경하면 첫 번째 렌더링 사이클에서는 변경된 State값 활용불가
- State값이 변경되면 컴포넌트가 무조건 재호출되고 두 번째 렌더링 사이클에서 변경된 State값을 활용가능
- 얕은 복사시 원본도 훼손되면서 변경 비교대상이 없어지면서 재랜더링 불가 (state는 원본과 비교하면서 동작)
- 복사시 스프레드 연산자 사용 (deep copy)

<hr>

## hooks

- 리액트 16버전에서 새로 나온 개념으로 리액트에서 자주쓰이는 상태관리, 생명주기에 관련된 내용들을 내장함수처럼 미리만들어진 라이브러리 형태의 기능모음
- hook이 등장하기 전까지는 클래스 기반으로 컴포넌트 생성, 상속을 적용하거나 반복되는 코드가 많아지는 비효율성

### hook이 나오게된 배경

- 리액트 16이전 버전에서는 클래스형 작업방식, 함수형작업
- 클래스형 작업방식: 여러클래스를 제작해서 서로 상속작업을 하다보니 코드의 가독성은 좋으나 반복코드작업을 많이 했었어야됨
- 함수형 작업방식 : hoc(high order component) 함수에 인수로 함수를 전달해서 새로운 함수를 리턴하는 방식, 코드 가독성이 많이 떨어짐
- 함수형 작업방식의 문제점을 hoc를 활요하는 기능들을 라이브러리처럼 hook라는 개념으로 미리 만들어서 배포

  2016년도 이후부터는 hook을 기반으로한 함수형 작업방식 대세를 이루면서 리액트의 인기가 높아짐

  리액트의 hook 삼대장 (useState, useEffect, useRef)
  useState - 상태값 관리
  useEffect - 생명주기 관리
  useRef - State외에 정적인 데이터를 관리하는 참조객체

  성능관리를 위한 hook (memo, useMemo, useCallback)
  양방향 데이터바인딩을 위한 hook (forwardRef, useImperativeHandle)

  ※ redux를 통한 전역상태관리
  라이브러리 목록 - (redux, redux-saga, redux-thunk, redux-toolit, recoil)

<hr>

## 이미지 import 방식

### src폴더 안쪽에서 이미지 import

- src폴더에 import하는 방식은 각각의 컴포넌트를 독립적으로 관리하기 용이

### public폴더 안쪽에서 이미지 경로 연결

- public폴더의 이미지 경로를 연결하는 방식은 페이지에 연결되는 이미지가 많을때 용이

<hr>

## useEffect

- 컴포넌트의 생명주기를 관장하는 hook
- lifeCycle : 생성(Mount), 갱신(State change), 소멸(UnMount)
- useEffect(실행함수, [의존성배열])

### 생명주기

- 의존성배열이 비어있으면 해당 구문은 처음 컴포넌트 마운트시 한번만 실행
- 의존성배열에 특정 State값이 등록되어 있으면 해당 State가 변경될 때마다 실행
- 특정 함수가 return될때에는 해당 컴포넌트 함수가 언마운트시 한번만 실행

- 의존성 배열이 비어있는 useEffect는 (컴포넌트의 생성을 캐치)
  ** useEffect(() => {}, []); **
  // 실사례1 - 외부데이터를 fetching하는 무거운 함수를 처음에 한번만 호출해야 될때
  // 실사례2 - window객체에 이벤트 바인딩할때 (브라우저 스크롤, 브라우저 리사이즈 이벤트)

- 의존성 배열에 특정 State가 등록되어 있는 useEffect문 (컴포넌트의 특정 State값 변경을 캐치)
  ** useEffect(() => {}, [Num]); **
  // 실사례1 - 외부 fetching데이터가 변경될때마다 로딩바 출력

- 특정 함수가 리턴되는 useEffect문 (컴포넌트의 소멸을 캐치)
  ** useEffect(() => {
  return () => {};
  }, []); **
  // 실사례1 - 팝업 컴포넌트 제거시 다시 스크롤바 기능 활성화 시킬때
  // 실사례2 - 해당 컴포넌트에 등록되어 있는 윈도우 객체의 이벤트 핸들러 함수
- 컴포넌트가 언마운트시에 동작되는 함수이므로 가상돔이 담겨있는 참조객체를 해당 함수안쪽에서 활용 불가
  컴포넌트가 사라질때 가상돔 제어를 위해서는 forwardRef를 활용해야 함

<hr>

## react안쪽에서 특정 가상돔 요소를 선택해야 될때 document.querySelector를 쓰면 안되는 이유

- 최신상태의 돔이 아님
- 리액트에서 관리되고 있는 상태의 돔이 아니기 때문에 추후 오류 발생가능성

<hr>

## useRef : 참조객체를 생성해주는 hook

- 특정 가상돔요소를 참조객체에 담아서 리액트안쪽에서 인베트 연결같은 제어를 하기 위함

### 사용방법

- 변수에 useRef를 활용해 초기 빈객체를 생성
- 해당 객체안에서 current 빈 프로퍼티가 자동으로 생성 (useRef 인수값이 초기 property에 담김)
- 빈 참조객체를 원하는 가상돔 요소에 ref로 연결
- 해당 참조객체안에서 ref연결된 가상돔이 담기게 되고 해당 감상돔이 담긴 참조객체를 이벤트문에서 호출

### useRef의 다른 사용예

- 컴포넌트 안쪽에서 특정 값을 변경하고 싶을때, 해당 값은 변경되더라도 컴포넌트를 재호출하고 싶지 않을때
- 컴포넌트가 다른 State값에 의해서 재호출되더라도 특정값을 초기화하지 않고 계속 유지시키고 싶을때

<hr>

## 라우터

- HashRouter - index.js 에서 App 컴포넌트를 감싸줌
- Route - app.js에서 각 페이지 라우트 설정 (path 설정, 연결할 컴포넌트 설정)
- Link, NavLink(activeStyle) - 활성화 기능 차이
- Switch - Route 분기처리 페이지별로 다른 스타일 구현

<hr>

## children

- 컴포넌트 태그로 감싸면 그 안쪽에 요소들은 children이라는 props 명으로 전달하여 사용한다

<hr>

## forwardRef

- 자식컴포넌트의 요소를 호출하는 부모컴포넌트에게 역으로 참조해서 전달
- useRef로 생성한 참조객체는 JSX는 참조 가능하나
  컴포넌트는 참조 불가

<hr>

## useImperativeHandle

- forwardRef문 안쪽에서 JSX를 역으로 반환하는것이 아닌 특정 객체를 반환처리

<hr>

## value와 defaultValue

- onChange 이벤트로 제어하지 않는 input요소의 value는 defaultValue속성으로 지정
- value: 리액트에서 관리되는 값, defaultValue: 일반DOM에 의해 관리되는 값

<hr>

## localStroge

- 모든 브라우저가 가지고 있는 경량의 저장소 (문자열 : 5MB)
- localStorage.setItem({key:'value'}) : 값 저장
- localStorage.getItem(key) : 값 불러오기
- 저장할 때는 문자화 해서 저장, 불러올 때는 data parsing

<hr>

## Prop drilling

- 자식의 값을 전달하기 위해서 불필요하게 props이 여러번에 걸쳐 전달되는 현상(개발 유지보수에 취약)
- 해당 문제해결 : redux (전역 상태관리)

### 전역상태관리

- 여러개의 컴포넌트에서 공통적으로 필요한 값들을 props로 전달하는게 아니라 컴포넌트 외부에 store라는 독립적인 저장 객체를 만들어서 원하는 컴포넌트 어디에서는 자유롭게 store의 값을 호출 수정 가능하게 만드는 전역 상태값 관리 개발

<hr>

## 메모이제이션

- 특정값을 강제로 메모리에 할당해서 값을 재활용 (속도가 빨라짐)
- 메모이제이션을 많이 할수록 메모리 점유율을 강제로 늘려서 성능을 올림
- 자바스크립트 엔진의 Garbage Collection에서 제외됨 (안쓰는 메모리를 정기적으로 제거해서 메모리 최적화)

:: 사용 예시

- 부모 컴포넌트가 재호출되면 자식 컴포넌트는 변경되는 요소가 없음에도 불구하고 무조건 같이 재호출됨

memo : 특정 컴포넌트 자체를 메모이제이션해서 부모컴포넌트가 재호출되더라도 자식 컴포넌트를 매번 재랜더링하는 것이 아닌 이전에 메모이제이션 해놓은 결과값을 재활용 (불필요한 재호출 막음)

- memo로 자식 컴포넌트를 메모이제이션 처리했더라도 부모로부터 props가 전달되면 memoization이 임시로 풀림
- 메모이제이션 되는 컴포넌트에 props로 값이 전달되고 있더라도 props로 변경하는 값이 아닌 state를 부모에서 변경하면 자식 컴포넌트는 메모이제이션 유지
- 메모이제이션 된 컴포넌트에 참조형 자료가 props로 전달되면 부모에서 해당 값을 변경하지 않아도 메모이제이션이 강제 해제
- 참조형 자료는 변수에 값자체가 담기는 것이 아닌 참조링크가 담기기 때문에 부모 컴포넌트가 재호출될때마다 변수에는 매번 새로운 참조링크가 담김. 결국 자식컴포넌트 입장에서는 props로 매번 다른값이 들어오므로 메모이제이션 해제
  => 해결 방안 npm i lodash
  lodash 의 isEqual: 참조링크가 아닌 참조링크가 가리키는 원본 데이터의 값을 비교

- isEqual로 자식 컴포넌트로 전달되는 참조형 자료에도 메모이제이션 유지시켰어도 함수가 전달되면 메모이제이션이 풀림 특정 컴포넌트가 빈번하게 재호출이 일어날때 그 안에 등록된 핸들러 함수도 계속해서 읽힘
- useCallback: props로 전달되는 함수나 빈번하게 재호출되는 컴포넌트 안쪽의 함수를 메모이제이션 처리
- useCallback으로 메모이제이션된 함수에 의존성배열을 등록하지 않으면 그 안쪽에 State상태값까지 메모이제이션처리
- 의존성배열에 특정 state값을 등록함으로써 해당 state가 변경될때에만 임시적으로 메모이제이션을 품
- useMemo : 함수의 리턴값 자체를 메모이제이션
- 특정 컴포넌트안쪽의 함수가 빈번하게 호출될때 리턴값이 무거운 연산을 통해 만들어진다면 해당 값 자체를 메모이제이션처리 해서 재연산을 막음

hoc (high order component) : 고착컴포넌트, 인수로 함수를 전달해서 새로운 함수를 반환하는 형태

<hr>

## useContext

- 자식 컴포넌트의 뎁스가 많은 경우 최상위 컴포넌트에서 최하위 컴포넌트까지 값을 일일이 전달하는 것이 비효율적
- 이처럼 props를 통해서 중간단계의 컴포넌트들이 같은 값을 전달하는 상황 (props drilling)
- Context API를 활용한 useContext hook을 활용하면 컴포넌트 외부에 전역으로 특정 값을 객체 형태로 관리하면서 컴포넌트에게 값 전달 가능
- createContext : context생성후 provider라는 컴포넌트를 통해 전역으로 특정 값을 전달
- useContext : createContext로 생성된 값을 원하는 자식컴포넌트에서 자유롭게 호출 가능

## useReducer

### useReducer 쓰는 이유

- 전역 데이터가 외부 요인에 따라 손쉽게 변경이 되면 안되기 때문에 구조적으로 데이터값을 관리하면서 정해진 규칙에 의해서만 변경가능하도록 강제하는 시스템적인 틀

### useReducer에서 중요한 개념

- dispatch (전달자) : 전역 State에 변경요청을 전달해주는 전달자
- reducer (변형자) : dispatch로 전달받은 요청에만 반응해서 전역 데이터를 변경해주는 변경자
- action (변경할 내용) : dispatch로 변경요청을 보낼 때 변경사항이 담겨있는 특별한 형태의 객체 {type: '변경방법', payload: '변경할 데이터'}

### useReducer의 개념 예시

: 고객이 계좌입금 용지내역을 작성 (자식 컴포넌트에서 액션객체 생성)
: 창구직원이 계좌입금 용지를 받아서 금고관리직원한테 전달 (dispatch가 액션값을 받아서 reducer에 전달)
: 금고관리직원은 전달받은 용지의 내용에 따라서 금고에 돈 저장 (reducer가 dispatch로 액션객체를 받아서 액션객체의 내용에 따라 전역데이터 변경)

<hr>

## redux

- useContext와 useReducer의 개념을 합쳐서 통합적으로 관리하는 전역데이터 관리 library

store : 어떤 컴포넌트에서든 자유롭게 데이터를 공유할 수 있게 컴포넌트 외부에 있는 독립적인 데이터 공간 (context)
reducer : store의 데이터를 변경하는 변형자함수 (dispatch로 전달하는 action객체로만 store데이터 변경가능)
action : 컴포넌트에서 reducer에 데이터변경 요청을 할때 쓰이는 특별한 형태의 객체 {type, payload}

## react-redux

- useDispatch : 컴포넌트에서 리듀서에 action객체를 전달해주는 함수
- useSelector : 컴포넌트에서 전역 스토어의 데이터를 가져오는 함수

redux 관련된 모든 함수들은 순수함수 형태로 구성이 되어야함 (Pure function)

- DOM이나 React등의 외부요인 없이 순수하게 자바스크립트로만 동작되는 함수
- Side effect(부수효과)를 발생시키지 않는 함수

<hr>

### 사용한것

- 갤러리 : Masonry
- 모션 : framer-motion
- 유튜브 : google api
- 지도 : kakao map
