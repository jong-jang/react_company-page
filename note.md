# 리액트 정리 노트

## RealDOM - 실제돔

- HTML태그를 이용해서 구조를 만들면 브라우저가 이를 해석해서 실제 DOM형태로 객체를 만들고 화면에 렌더링하는 방식

<hr>

## VirtualDOM - 가상돔

- 실제 브라우저에 리얼돔으로 변환되기전 메모리상에서 DOM구조를 스크립트로 가상으로 만들어서 기존의 DOM구조와 차이점을 분석
- 기존DOM에서 변경되는 부분을 메모리상에서 빠르게 수정해서 리얼돔으로 출력하는 형태 JSX
- 리액트 자체적으로 가상돔을 편하게 생성해주는 문법체계 (자바스크립트로 일일이 노드를 생성해서 돔을 제작하던 방식을 마치 HTML입력하는 것처럼 편하게 변경한 표현방식)

<hr>

## 컴포넌트 함수

- JSX를 반환해서 가상돔을 생성해주는 함수
- 함수명을 대문자로 시작
- export형식으로 내보내야지 다른 파일에서 import해올수 있음
- 화살표함수 형태로도 제작 가능
- 하나의 컴포넌트 함수는 단일 JSX요소만 리턴 가능
- 복수개의 요소를 리턴하고 싶을때에는 wrapping태그로 감싸줌
- 중첩되는 wrapping요소가 불필요시에는 fragment로 감싸줌 <></>
- 화살표함수로 컴포넌트 제작시 중괄호 return문은 생략 가능

<hr>

## e.target vs e.currentTarget

- e.currentTarget : 이벤트구문상에서 이벤트가 연결되어 있는 선택자를 지칭
- e.target : 화면상에서 실제 이벤트가 발생한 대상을 지칭

<hr>

## 불변성 (immutability)

- 불변성 (immutability) : 원형을 훼손시키지 않으면서 원본을 유지한채로 복사본을 변경후 비교하는 형태
- 리액트에서는 원본대비 변경된 부분을 비교해서 화면을 렌더링하기 때문에 불변성 유지가 필수
- 리액트에서는 원본데이터와 변경될 데이터가 모두 있어야함
- 참조형 자료를 변경할때에는 무조건 deep copy처리
- 특정요소를 반복 돌릴때에는 무조건 map함수 활용(원배열을 복사하면서 반복처리)
- JSX 안쪽에서는 map함수 외에는 반복처리 불가
- JSX에서 동적으로 반복생성되는 요소는 무조건 고유의 key값을 부여 (리액트로 하여금 반복도를 개별적으로 인지시키기 위함)

<hr>

## 리액트에서의 데이터 전달 방식 (단뱡향 데이터 바인딩 채택)

- 부모에서 자식으로 데이터 전달 가능
- 부모에서 자식으로 데이터를 전달하기 위해서는 props라는 파라미터 활용

<hr>

## State

- 컴포넌트 함수 안쪽에서 변수에 특정 정보값을 담아놓으면 해당 함수가 호출될 때마다 다시 변수에 담긴 값이 초기화 됨
- 컴포넌트함수 안쪽에서 특정 정보값을 이벤트에 의해서 바꾸면 컴포넌트함수는 다음번 호출때 변경점이 반영이 됨
- State: 컴포넌트 내부에서 특정 정보값을 담아두는 그릇 - 해당 값이 바뀌게 되면 컴포넌트 함수자체를 재호출 (재랜더링) 바뀐 값으로 새로운 화면을 갱신
- [state가 담김 그릇, 해당 State값을 변경해주는 전용함수] = useState(초기값)
- uss 입력후 3번째 탭 선택하면 자동완성 가능
- 컴포넌트에서 State값을 변경하면 첫 번째 렌더링 사이클에서는 변경된 State값 활용불가
- State값이 변경되면 컴포넌트가 무조건 재호출되고 두 번째 렌더링 사이클에서 변경된 State값을 활용가능
- 얕은 복사시 원본도 훼손되면서 변경 비교대상이 없어지면서 재랜더링 불가 (state는 원본과 비교하면서 동작)
- 복사시 스프레드 연산자 사용 (deep copy)

<hr>

## hooks

- 리액트 16버전에서 새로 나온 개념으로 리액트에서 자주쓰이는 상태관리, 생명주기에 관련된 내용들을 내장함수처럼 미리만들어진 라이브러리 형태의 기능모음
- hook이 등장하기 전까지는 클래스 기반으로 컴포넌트 생성, 상속을 적용하거나 반복되는 코드가 많아지는 비효율성

### hook이 나오게된 배경

- 리액트 16이전 버전에서는 클래스형 작업방식, 함수형작업
- 클래스형 작업방식: 여러클래스를 제작해서 서로 상속작업을 하다보니 코드의 가독성은 좋으나 반복코드작업을 많이 했었어야됨
- 함수형 작업방식 : hoc(high order component) 함수에 인수로 함수를 전달해서 새로운 함수를 리턴하는 방식, 코드 가독성이 많이 떨어짐
- 함수형 작업방식의 문제점을 hoc를 활요하는 기능들을 라이브러리처럼 hook라는 개념으로 미리 만들어서 배포

  2016년도 이후부터는 hook을 기반으로한 함수형 작업방식 대세를 이루면서 리액트의 인기가 높아짐

  리액트의 hook 삼대장 (useState, useEffect, useRef)
  useState - 상태값 관리
  useEffect - 생명주기 관리
  useRef - State외에 정적인 데이터를 관리하는 참조객체

  성능관리를 위한 hook (memo, useMemo, useCallback)
  양방향 데이터바인딩을 위한 hook (forwardRef, useImperativeHandle)

  ※ redux를 통한 전역상태관리
  라이브러리 목록 - (redux, redux-saga, redux-thunk, redux-toolit, recoil)

<hr>

## 이미지 import 방식

### src폴더 안쪽에서 이미지 import

- src폴더에 import하는 방식은 각각의 컴포넌트를 독립적으로 관리하기 용이

### public폴더 안쪽에서 이미지 경로 연결

- public폴더의 이미지 경로를 연결하는 방식은 페이지에 연결되는 이미지가 많을때 용이

<hr>

## useEffect

- 컴포넌트의 생명주기를 관장하는 hook
- lifeCycle : 생성(Mount), 갱신(State change), 소멸(UnMount)
- useEffect(실행함수, [의존성배열])

### 생명주기

- 의존성배열이 비어있으면 해당 구문은 처음 컴포넌트 마운트시 한번만 실행
- 의존성배열에 특정 State값이 등록되어 있으면 해당 State가 변경될 때마다 실행
- 특정 함수가 return될때에는 해당 컴포넌트 함수가 언마운트시 한번만 실행

- 의존성 배열이 비어있는 useEffect는 (컴포넌트의 생성을 캐치)
  ** useEffect(() => {}, []); **
  // 실사례1 - 외부데이터를 fetching하는 무거운 함수를 처음에 한번만 호출해야 될때
  // 실사례2 - window객체에 이벤트 바인딩할때 (브라우저 스크롤, 브라우저 리사이즈 이벤트)

- 의존성 배열에 특정 State가 등록되어 있는 useEffect문 (컴포넌트의 특정 State값 변경을 캐치)
  ** useEffect(() => {}, [Num]); **
  // 실사례1 - 외부 fetching데이터가 변경될때마다 로딩바 출력

- 특정 함수가 리턴되는 useEffect문 (컴포넌트의 소멸을 캐치)
  ** useEffect(() => {
  return () => {};
  }, []); **
  // 실사례1 - 팝업 컴포넌트 제거시 다시 스크롤바 기능 활성화 시킬때
  // 실사례2 - 해당 컴포넌트에 등록되어 있는 윈도우 객체의 이벤트 핸들러 함수
- 컴포넌트가 언마운트시에 동작되는 함수이므로 가상돔이 담겨있는 참조객체를 해당 함수안쪽에서 활용 불가
  컴포넌트가 사라질때 가상돔 제어를 위해서는 forwardRef를 활용해야 함

<hr>

## react안쪽에서 특정 가상돔 요소를 선택해야 될때 document.querySelector를 쓰면 안되는 이유

- 최신상태의 돔이 아님
- 리액트에서 관리되고 있는 상태의 돔이 아니기 때문에 추후 오류 발생가능성

<hr>

## useRef : 참조객체를 생성해주는 hook

- 특정 가상돔요소를 참조객체에 담아서 리액트안쪽에서 인베트 연결같은 제어를 하기 위함

### 사용방법

- 변수에 useRef를 활용해 초기 빈객체를 생성
- 해당 객체안에서 current 빈 프로퍼티가 자동으로 생성 (useRef 인수값이 초기 property에 담김)
- 빈 참조객체를 원하는 가상돔 요소에 ref로 연결
- 해당 참조객체안에서 ref연결된 가상돔이 담기게 되고 해당 감상돔이 담긴 참조객체를 이벤트문에서 호출

### useRef의 다른 사용예

- 컴포넌트 안쪽에서 특정 값을 변경하고 싶을때, 해당 값은 변경되더라도 컴포넌트를 재호출하고 싶지 않을때
- 컴포넌트가 다른 State값에 의해서 재호출되더라도 특정값을 초기화하지 않고 계속 유지시키고 싶을때

<hr>

## 라우터

- HashRouter - index.js 에서 App 컴포넌트를 감싸줌
- Route - app.js에서 각 페이지 라우트 설정 (path 설정, 연결할 컴포넌트 설정)
- Link, NavLink(activeStyle) - 활성화 기능 차이
- Switch - Route 분기처리 페이지별로 다른 스타일 구현

<hr>

## children

- 컴포넌트 태그로 감싸면 그 안쪽에 요소들은 children이라는 props 명으로 전달하여 사용한다

<hr>

## forwardRef

- 자식컴포넌트의 요소를 호출하는 부모컴포넌트에게 역으로 참조해서 전달
- useRef로 생성한 참조객체는 JSX는 참조 가능하나
  컴포넌트는 참조 불가

<hr>

## useImperativeHandle

- forwardRef문 안쪽에서 JSX를 역으로 반환하는것이 아닌 특정 객체를 반환처리

<hr>

## value와 defaultValue

- onChange 이벤트로 제어하지 않는 input요소의 value는 defaultValue속성으로 지정
- value: 리액트에서 관리되는 값, defaultValue: 일반DOM에 의해 관리되는 값

<hr>

## localStroge

- 모든 브라우저가 가지고 있는 경량의 저장소 (문자열 : 5MB)
- localStorage.setItem({key:'value'}) : 값 저장
- localStorage.getItem(key) : 값 불러오기
- 저장할 때는 문자화 해서 저장, 불러올 때는 data parsing

<hr>

### 사용한것

- 갤러리 : Masonry
- 모션 : framer-motion
- 유튜브 : google api
- 지도 : kakao map
